declare module "accessors/clone" {
    /**
     * @module accessors
     */
    /**
     * Options to modify the behaviour of the clone function
     */
    export interface CloneOptions {
        /** Flag to specify that functions should be copied by reference rather than converted to empty objects */
        copyFunctions?: boolean;
    }
    /**
     *
     * Creates a deep clone of a value
     *
     * @typeparam T The type of the original value
     * @param original The value to clone
     * @param options Config options
     * @return Returns the deep cloned value
     *
     */
    export default function clone<T>(original: T, options?: CloneOptions): T;
}
declare module "internal/patterns/arrayAccessor" {
    export const arrayAccessor: RegExp;
    export default arrayAccessor;
}
declare module "accessors/get" {
    /**
     *
     * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.
     *
     * @param object The object to query
     * @param path The path of the property to get
     * @param defaultValue The value returned for undefined resolved values
     * @return The value if it exists, if not then either the default value is returned or undefined
     *
     */
    export default function get<T = any>(object: object, path: string[] | string, defaultValue?: T): T;
}
declare module "array/flatten" {
    /**
     * @module array
     */
    /**
     *
     * Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
     *
     * @typeparam T The type of the items in the array, specify this type parameter to avoid type widening on deeply nested arrays
     * @param array The array to be flattened.
     * @param depth The depth level specifying how deep a nested array structure should be flattened. Defaults to `Infinity`.
     * @return The flattened array.
     *
     * @example
     * ```typescript
     *
     * flatten<number>([1, [2, 3], 4, [5, [6, 7] ], 8])
     * // Expected output: [1, 2, 3, 4, 5, 6, 7, 8]
     * ```
     *
     */
    export default function flatten<T>(array: (T[][] | T[] | T)[], depth?: number): T[];
}
declare module "accessors/pick" {
    /**
     *
     * Creates a new object containing only the properties of `object` that are specified in `keys`.
     *
     * @param object The base object that properties will be picked from
     * @param keys The keys to pick
     *
     * @example
     * ```typescript
     *
     * const original = { foo: 'hello', bar: 'world', baz: false, something: [1, 2, 3] }
     * const picked = pick(original, 'foo', 'something')
     *
     * console.log(picked) // { foo: 'hello', something: [1, 2, 3] }
     * console.log(Object.keys(picked)) // ['foo', 'something']
     * ```
     *
     */
    export default function pick<T extends Record<string, any>, U extends keyof T>(object: T, ...keys: U[]): Pick<T, U>;
    export default function pick<T extends Record<string, any>, U extends keyof T>(object: T, keys: U[]): Pick<T, U>;
}
declare module "accessors/set" {
    /**
     *
     * Sets the value at path of object. If a portion of path doesn't exist, it's created. Arrays are created for missing
     * index properties while objects are created for all other missing properties.
     *
     * @param object The object to modify
     * @param path The path of the property to set
     * @param value The value to set
     *
     */
    export default function set(object: Record<string, any> | any[], path: string[] | string, value: any): void;
}
declare module "accessors/index" {
    /**
     * @module accessors
     * @preferred
     */
    export { default as clone } from "accessors/clone";
    export { default as get } from "accessors/get";
    export { default as pick } from "accessors/pick";
    export { default as set } from "accessors/set";
}
declare module "array/filterBy" {
    /**
     *
     *  Allows filtering of an array by querying a property with a getter path instead of a callback function.
     *
     * @param array The array of object to filter
     * @param path The path of the property to filter
     * @param value The value of the property to filter
     * @return Array filtered according to property and past value
     *
     */
    export default function filterBy(array: object[], path: string | string[], value: any): object[];
}
declare module "array/flatMap" {
    /**
     *
     * Calls a function on every item in an array and concatenates the resulting arrays into a single flat array.
     *
     * @typeparam TValue The type of items in the input array
     * @typeparam TNext the type of items in the output array
     * @param array The input array to be mapped
     * @param fn The functions used to generate the new items
     * @return A flat array of the resulting values
     *
     * @example
     * ```typescript
     *
     * const items = flatMap(['foo', 'bar'], word => word.split())
     * // Returns ['f', 'o', 'o', 'b', 'a', 'r']
     * ```
     *
     */
    export default function flatMap<TValue, TNext>(array: TValue[], fn: (value: TValue, index?: number) => TNext[]): TNext[];
}
declare module "array/partitionArray" {
    /**
     * @module array
     */
    /**
     *
     * Partitions an array using a provided predicate function. All elements satisfying the predicate are part of the first returned array,
     * and all elements that don't are in the second.
     *
     * @param array The array to partition
     * @param predicate Function to test each item. Items that return true are placed in the first array,
     * otherwise they are returned in the second array
     * @param contect The context to call the predicate function in
     * @return Two arrays, the first containing all items that satisfied the predicate, the second containing the rest
     *
     * @example
     * ```typescript
     *
     * partitionArray([1, 2, 3, 4], x => x % 2)
     * // Returns [[1, 3], [2, 4]]
     * ```
     *
     */
    export default function partitionArray<T>(array: T[], predicate: (value: T, index: number, array: T[]) => boolean, context?: any): [T[], T[]];
}
declare module "array/updateItem" {
    /**
     *
     * Updates an item in an array and returns a new array
     *
     * @param array The array to update
     * @param query A map of property paths (period delimited string) to values used to test if an object should be updated,
     * the paths are used in the get function
     * @param updateCallback A callback used to update the item
     * @return The array with the updated item
     *
     */
    export default function updateItem(array: object[], query: object, updateCallback: (item: any) => any): object[];
}
declare module "array/index" {
    /**
     * @module array
     * @preferred
     */
    export { default as filterBy } from "array/filterBy";
    export { default as flatMap } from "array/flatMap";
    export { default as flatten } from "array/flatten";
    export { default as partitionArray } from "array/partitionArray";
    export { default as updateItem } from "array/updateItem";
}
declare module "async/makeCancelable" {
    /**
     * @module async
     */
    /** An error that indicates a promise has rejected because it was canceled */
    export const canceledError: {
        isCanceled: boolean;
    };
    /** A promise that can have it's resolution cancelled */
    export interface CancelableWrappedPromise<T> extends Promise<T> {
        cancel(): void;
    }
    /**
     *
     * Allows the provided promise to be canceled after starting. This does not stop the promise from executing but will
     * cause it to reject with the value `{ isCanceled: true }` once it finishes, regardless of outcome.
     *
     * @param promise The promise that is executing
     * @return The cancelable version of the promise
     *
     * @example
     * ```typescript
     *
     * const promise = new Promise((res, rej) => {
     *   setTimeout(() => res('I finished!'), 3000)
     * })
     *
     * // Create a cancelable version of the promise
     * const cancelablePromise = makeCancelable(promise)
     *
     * // Stop the cancelable promise from resolving
     * cancelablePromise.cancel()
     *
     * promise
     *   .then(result => console.log('Normal', result)) // This will log `'I finished!'` after 3000ms
     *   .catch(err => console.log('Normal', err)) // Will reject as per normal
     *
     * cancelablePromise
     *   .then(result => console.log('Cancelable', result)) // Never fires, the promise will not resolve after being cancelled
     *   .catch(err => console.log('Cancelable', err)) // Resolves after 3000ms with the value `{ isCanceled: true }`
     * ```
     *
     */
    export default function makeCancelable<T>(promise: Promise<T>): CancelableWrappedPromise<T>;
}
declare module "async/CancelablePromise" {
    /** @module async */
    /** */
    import { canceledError } from "async/makeCancelable";
    export { canceledError };
    /**
     *
     * Creates a promise that can be canceled after starting. Canceling the promise does not stop it from executing but will
     * cause it to reject with the value `{ isCanceled: true }` once it finishes, regardless of outcome.
     *
     * ```ts
     *
     * const promise = new CancelablePromise(res => setTimeout(res, 3000, 'I finished!'))
     *
     * // Stop the cancelable promise from resolving
     * cancelablePromise.cancel()
     *
     * cancelablePromise
     *   .then(result => console.log('Cancelable', result)) // Never fires, the promise will not resolve after being cancelled
     *   .catch(err => console.log('Cancelable', err)) // Resolves after 3000ms with the value `{ isCanceled: true }`
     * ```
     *
     */
    export class CancelablePromise<T extends any> extends Promise<T> {
        private canceled;
        protected promise: Promise<T>;
        get [Symbol.toStringTag](): string;
        get hasCanceled(): boolean;
        constructor(executor: (resolve: (value: T) => void, reject: (err?: any) => void) => void);
        cancel(): void;
        then<TResult1, TResult2>(onfulfilled: (value: T) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
        catch<TResult>(onrejected: (reason: any) => TResult | PromiseLike<TResult>): Promise<T | TResult>;
        finally(onfinally: () => void): Promise<T>;
    }
    export default CancelablePromise;
}
declare module "async/pause" {
    /**
     * @module async
     */
    /**
     *
     * Creates a promise that resolves in the provided number of milliseconds.
     *
     * This function is basically a promise version of `setTimeout`
     *
     * @param ms The number of ms to pause for
     * @return The executing promise
     *
     * @example
     * ```typescript
     *
     * async function run() {
     *   console.log('first log')
     *   await pause(500)
     *
     *   // Will run 500 milliseconds after the first
     *   console.log('second log')
     * }
     * ```
     *
     */
    export default function pause(ms: number): Promise<unknown>;
}
declare module "async/index" {
    /**
     * @module async
     * @preferred
     */
    export { default as CancelablePromise } from "async/CancelablePromise";
    export { default as makeCancelable } from "async/makeCancelable";
    export { default as pause } from "async/pause";
}
declare module "function/partial" {
    /**
     * @module function
     */
    /**
     *
     * Creates a function that invokes `func` with `partials` prepended to the arguments it receives.
     *
     * @param func The function to partially apply arguments to
     * @param argsBound The arguments to be partially applied
     *
     * @example
     * ```typescript
     *
     * const addNums = (a, b, c) => a + b + c
     * const addNumsTo5 = partial(addNums, 5)
     *
     * addNumsTo5(1, 3) // => 9
     * ```
     *
     */
    export default function partial(func: (...args: any[]) => any, ...argsBound: any[]): (...remainingArgs: any[]) => any;
}
declare module "function/index" {
    /**
     * @module function
     * @preferred
     */
    export { default as partial } from "function/partial";
}
declare module "tests/runTest" {
    /**
     * @module tests
     */
    /**
     *
     * Runs a test based on input(s), if an array is provided then the items are passed as arguments to the function
     * being tested, if anything else is provided then it is passed directly to the function
     *
     * @param testCase A tuple of inputs and expected output
     * @param func The function to test
     * @param testVerb The jest `expect` verb to use when testing - defaults to `toBe`
     *
     * @example
     * ```typescript
     *
     * runTest([[3, 5], 8], (a, b) => a + b)
     * ```
     *
     */
    export default function runTest(testCase: [any, any], func: (...args: any[]) => any, testVerb?: string): void;
}
declare module "tests/batchTest" {
    /**
     * Options to customize the behaviour of the batchTest function
     */
    export interface BatchTestOptions {
        /** The jest `expected` verb to use when running the test */
        verb?: string;
        /**
         * The function used to run the test, by default the jest library is used. This is mainly here to all the function
         * to be tested
         */
        runner?: (testCase: [any, any], func: (...args: any[]) => any, testVerb?: string) => void;
    }
    /**
     *
     * Utility function for running batches of tests with a single call
     *
     * @param func The function to test
     * @param cases An array of test case tuples (inputs and expected outputs)
     * @param options Configuration options
     *
     * @example
     * ```typescript
     *
     * batchTest(double, [[2, 4], [5, 10]])
     * ```
     *
     */
    export default function batchTest(func: (...args: any[]) => any, cases: any[][], { verb, runner }?: BatchTestOptions): void;
}
declare module "tests/buildCaseArray" {
    /**
     * @module tests
     */
    /**
     *
     * Builds an array of test cases with a common output
     *
     * @param testInputs An array of test inputs to build into the case array
     * @param output The single output that should be paired with every input
     * @return Returns the array of test cases
     *
     * @example
     * ```typescript
     *
     * const evenTests = [...buildCaseArray([2, 4, 6], true), ...buildCaseArray([1, 3, 5], false)]
     * ```
     *
     */
    export default function buildCaseArray(testInputs: any[], output: any): any[][];
}
declare module "tests/index" {
    /**
     * @module tests
     * @preferred
     */
    export { default as batchTest } from "tests/batchTest";
    export { default as buildCaseArray } from "tests/buildCaseArray";
    export { default as runTest } from "tests/runTest";
}
declare module "internal/patterns/splitCamelCase" {
    /** Regex pattern to split the camel case section into it's parts */
    const splitCamelCase: RegExp;
    export default splitCamelCase;
}
declare module "internal/wordLists/articles" {
    /**
     * Indefinite Articles
     * @internal
     */
    const articles: string[];
    export default articles;
}
declare module "internal/wordLists/conjunctions" {
    /**
     * Coordinating Conjuctions
     * @internal
     */
    const conjunctions: string[];
    export default conjunctions;
}
declare module "internal/wordLists/others" {
    /**
     * Other miscellaneous words
     * @internal
     */
    const others: string[];
    export default others;
}
declare module "internal/wordLists/prepositions" {
    /**
     * All prepositions
     * @internal
     */
    export const all: string[];
    /**
     * Prepositions shorter than 5 characters
     * @internal
     */
    export const short: string[];
    export default all;
}
declare module "internal/wordLists/titleExceptions" {
    /** Lists of words that shouldn't be capitalized in titles */
    const except: string[];
    export default except;
}
declare module "transforms/capitalize" {
    /**
     * @module transforms
     */
    /**
     *
     * Capitalize the first letter of a string
     *
     * @param text The string to be capitalized
     * @return Returns the capitalized string
     *
     * @example
     * ```typescript
     *
     * const name = capitalize('bob') // => 'Bob'
     * ```
     *
     */
    export default function capitalize(text: string): string;
}
declare module "transforms/camelToTitle" {
    /**
     *
     * Transforms the provided camel-case string to title case using rules from
     * [capitalizemytitle.com](https://capitalizemytitle.com/#)
     *
     * When to capitalize:
     * - Capitalize the first word in the title
     * - Capitalize the last word in the title
     *
     * When not to capitalize
     * - articles (a, an, the)
     * - coordinating conjuctions (and, but, for)
     * - short prepositions (less than 5 letters - at, by, from)
     *
     * When one of the above conditions is not met then the word is assumed to be some other important word
     * and it is capitalized
     *
     * @param input The camel-case string to be converted
     * @return Returns the transformed title case string
     *
     * @example
     * ```typescript
     *
     * camelToTitle('iLoveCamels') // => 'I Love Camels'
     * ```
     *
     */
    export default function camelToTitle(input: string): string;
}
declare module "transforms/getAcronym" {
    /**
     *
     * Condense a provided string into a 2 or 3 letter acronym using the following rules
     * - If there is only a single word return the first 3 letters
     * - If there are more than 3 words filter out articles, conjunctions and short prepositions
     *
     * @param title The string to convert to an acronym
     * @return Returns the acronym string
     *
     * @example
     * ```typescript
     *
     * const acronym = getAcronym('Empire Strikes Back') // => 'ESB'
     * ```
     *
     */
    export default function getAcronym(title: string): string;
}
declare module "transforms/normalizeURL" {
    /**
     *
     * Sanitises and safely joins sections of a URL, this includes removing duplicate slashes in the path and
     * ensuring correctly formatted protocols.
     *
     * @param urlParts The URL parts to be joined and normalized
     * @return Returns the joined and normalized URL parts as a string
     *
     * @example
     * ```typescript
     *
     * const url = normalizeURL('https://cahilfoley.github.io/', '/utils') // => 'https://cahilfoley.github.io/utils'
     * ```
     *
     */
    export default function noramlizeURL(...urlParts: string[]): string;
}
declare module "transforms/toCamel" {
    export interface ToCamelOptions {
        keepAcronyms?: boolean;
    }
    /**
     *
     * Transforms the provided string into camel-case.
     *
     * If the string contains a combination of upper and lower-case letters then the method
     * will retain the capitalization of acronyms. This behaviour can be explicitly toggled
     * on or off with the `keepAcronyms` option.
     *
     * @param input The string to be converted
     * @return Returns the camel-case string
     *
     * @example
     * ```typescript
     *
     * toCamel('ILoveCamels') // => 'iLoveCamels'
     * toCamel('User ID') // => 'userID'
     * ```
     *
     */
    export default function toCamel(input: string): string;
    export default function toCamel(input: string, options: ToCamelOptions): string;
}
declare module "transforms/toProperList" {
    /**
     * @module transforms
     */
    /**
     *
     * Joins together several strings or numbers in a properly formatted English list. The last two items are seperated by the word
     * 'and' and the remaining items are seperated by a comma and space.
     *
     * @param items Array of strings
     *
     * @example
     * ```typescript
     *
     * const itemsString = toProperList(['apples', 'pears', 'bananas']) // => 'apples, pears and bananas'
     * ```
     *
     */
    export function toProperList(items: string[]): string;
    export function toProperList(...items: string[]): string;
    export default toProperList;
}
declare module "transforms/index" {
    /**
     * @module transforms
     * @preferred
     */
    export { default as camelToTitle } from "transforms/camelToTitle";
    export { default as capitalize } from "transforms/capitalize";
    export { default as getAcronym } from "transforms/getAcronym";
    export { default as normalizeURL } from "transforms/normalizeURL";
    export { default as toCamel } from "transforms/toCamel";
    export { default as toProperList } from "transforms/toProperList";
}
declare module "validation/isNonEmptyString" {
    /**
     * @module validation
     */
    /**
     *
     * Checks if a value provided is of type string and has a non-zero length. If the value is not a string
     * or it is an empty string then the function returns false
     *
     * @param text The text to validate
     * @return True if the value is an empty string, false otherwise
     *
     * @example
     * ```typescript
     *
     * const valid = isNonEmptyString('hello') // => true
     * ```
     *
     */
    export default function isNonEmptyString(text: string): boolean;
}
declare module "internal/patterns/emailAddress" {
    const emailPattern: RegExp;
    export default emailPattern;
}
declare module "validation/isValidEmail" {
    /**
     *
     * Tests if the input string is in the form of a valid email address
     *
     * @param text The text to
     * @return Returns true if the input is a valid email address otherwise returns false
     *
     * @example
     * ```typescript
     *
     * isValidEmail(`no spaces@sham.co`) // => false
     * ```
     *
     */
    export default function isValidEmail(text: string): boolean;
}
declare module "internal/patterns/validURL" {
    /** Regular expression to match URL patterns, developed using this handy tool https://regex101.com/r/lQ1nI3/1 */
    const urlRegex: RegExp;
    export default urlRegex;
}
declare module "validation/isValidURL" {
    /**
     *
     * Checks if a value provided is of type string and is a valid URL. If the value is not a string
     * or it is an empty string then the function returns false
     *
     * @param text The text to validate
     * @return Returns true if the input is a valid URL otherwise returns false
     *
     * @example
     * ```typescript
     *
     * const valid = isValidURL('http://www.google.com') // returns true
     * ```
     *
     */
    export default function isValidURL(text: string): boolean;
}
declare module "validation/index" {
    /**
     * @module validation
     * @preferred
     */
    export { default as isNonEmptyString } from "validation/isNonEmptyString";
    export { default as isValidEmail } from "validation/isValidEmail";
    export { default as isValidURL } from "validation/isValidURL";
}
declare module "index" {
    export * from "accessors/index";
    export * from "array/index";
    export * from "async/index";
    export * from "function/index";
    export * from "tests/index";
    export * from "transforms/index";
    export * from "validation/index";
}
