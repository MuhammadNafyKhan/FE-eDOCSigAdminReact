var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * @module accessors
 */
define("accessors/clone", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function clone(original, options = {}) {
        let output;
        // Can't clone functions, only copy if the flag is set
        if (typeof original === 'function')
            output = options.copyFunctions ? original : {};
        // Nulls will be caught as objects later so return them now
        else if (original === null)
            output = null;
        // If the input is a date, create a new one with the same value
        else if (original instanceof Date)
            output = new Date(original.valueOf());
        // If the input is an array, clone each item
        else if (Array.isArray(original))
            output = original.map(value => clone(value, options));
        // If the input is an object, clone each value onto a new object
        else if (typeof original === 'object') {
            output = {};
            for (const [key, value] of Object.entries(original)) {
                output[key] = clone(value, options);
            }
        }
        // If anything above matched the return the output
        if (output !== undefined)
            return output;
        // Don't know how to handle this type, just return the original
        return original;
    }
    exports.default = clone;
    module.exports = clone;
    module.exports.clone = clone;
    module.exports.default = clone;
});
define("internal/patterns/arrayAccessor", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayAccessor = /\[(\d+)\]/g;
    exports.default = exports.arrayAccessor;
});
/**
 * @module accessors
 */
define("accessors/get", ["require", "exports", "internal/patterns/arrayAccessor"], function (require, exports, arrayAccessor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    arrayAccessor_1 = __importDefault(arrayAccessor_1);
    /**
     *
     * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.
     *
     * @param object The object to query
     * @param path The path of the property to get
     * @param defaultValue The value returned for undefined resolved values
     * @return The value if it exists, if not then either the default value is returned or undefined
     *
     */
    function get(object, path, defaultValue) {
        // If the path was a string, split it by periods
        if (typeof path === 'string')
            path = path.replace(arrayAccessor_1.default, '.$1').split('.');
        const nextKey = path.shift();
        // Up to the last section of the path, get the value now
        if (path.length === 0) {
            const value = object[nextKey];
            if (value !== undefined)
                return value;
            return defaultValue;
        }
        // If the next key isn't an object then we can't read it
        if (!object[nextKey] || typeof object[nextKey] !== 'object')
            return defaultValue;
        // Call get recursively with the next section of the path
        return get(object[nextKey], path, defaultValue);
    }
    exports.default = get;
});
/**
 * @module array
 */
define("array/flatten", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
     *
     * @typeparam T The type of the items in the array, specify this type parameter to avoid type widening on deeply nested arrays
     * @param array The array to be flattened.
     * @param depth The depth level specifying how deep a nested array structure should be flattened. Defaults to `Infinity`.
     * @return The flattened array.
     *
     * @example
     * ```typescript
     *
     * flatten<number>([1, [2, 3], 4, [5, [6, 7] ], 8])
     * // Expected output: [1, 2, 3, 4, 5, 6, 7, 8]
     * ```
     *
     */
    function flatten(array, depth = Infinity) {
        return array.reduce((accumulator, value) => Array.isArray(value) && depth-- > 0
            ? accumulator.concat(flatten(value, depth))
            : accumulator.concat(value), []);
    }
    exports.default = flatten;
});
/**
 * @module accessors
 */
define("accessors/pick", ["require", "exports", "array/flatten"], function (require, exports, flatten_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    flatten_1 = __importDefault(flatten_1);
    function pick(object, ...keys) {
        const resolvedKeys = flatten_1.default(keys);
        const output = resolvedKeys.reduce((output, key) => {
            output[key] = object[key];
            return output;
        }, {});
        return output;
    }
    exports.default = pick;
    module.exports = pick;
    module.exports.pick = pick;
    module.exports.default = pick;
});
/**
 * @module accessors
 */
define("accessors/set", ["require", "exports", "internal/patterns/arrayAccessor"], function (require, exports, arrayAccessor_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    arrayAccessor_2 = __importDefault(arrayAccessor_2);
    /**
     * Creates an array/object as the next property if required
     * @private
     */
    function ensureNextSectionIsValid([next, nextPlusOne], object) {
        // If the next path item is a number then the item we are about to enter is an array
        if (!Number.isNaN(+nextPlusOne)) {
            // If the next item isn't already an array then create it
            if (!Array.isArray(object[next]))
                object[next] = [];
        }
        // If the next key isn't an object - make it one
        else if (!object[next] || typeof object[next] !== 'object') {
            object[next] = {};
        }
    }
    /**
     *
     * Sets the value at path of object. If a portion of path doesn't exist, it's created. Arrays are created for missing
     * index properties while objects are created for all other missing properties.
     *
     * @param object The object to modify
     * @param path The path of the property to set
     * @param value The value to set
     *
     */
    function set(object, path, value) {
        // If the path was a string, split it by periods and array accessors
        if (typeof path === 'string')
            path = path.replace(arrayAccessor_2.default, '.$1').split('.');
        const nextKey = path.shift();
        // If this is the end of the path then set the value and end
        if (path.length === 0)
            return void (object[nextKey] = value);
        // Still got more steps to go, create the next step if required
        ensureNextSectionIsValid([nextKey, path[0]], object);
        // Call set recursively with the next section of the path
        set(object[nextKey], path, value);
    }
    exports.default = set;
    module.exports = set;
    module.exports.set = set;
    module.exports.default = set;
});
/**
 * @module accessors
 * @preferred
 */
define("accessors/index", ["require", "exports", "accessors/clone", "accessors/get", "accessors/pick", "accessors/set"], function (require, exports, clone_1, get_1, pick_1, set_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = clone_1.default;
    exports.get = get_1.default;
    exports.pick = pick_1.default;
    exports.set = set_1.default;
});
/**
 * @module array
 */
define("array/filterBy", ["require", "exports", "accessors/get"], function (require, exports, get_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    get_2 = __importDefault(get_2);
    /**
     *
     *  Allows filtering of an array by querying a property with a getter path instead of a callback function.
     *
     * @param array The array of object to filter
     * @param path The path of the property to filter
     * @param value The value of the property to filter
     * @return Array filtered according to property and past value
     *
     */
    function filterBy(array, path, value) {
        let result = array.filter(element => {
            let copyPath = path;
            if (typeof path !== 'string') {
                // If the path is an array, it copies the value because the get function modifies it
                copyPath = [...path];
            }
            // Attempts to fetch past property value
            const tryGet = get_2.default(element, copyPath);
            // Compares the returned value of the get function and the value fetched
            return tryGet !== undefined && tryGet === value;
        });
        return result;
    }
    exports.default = filterBy;
});
/**
 * @module array
 */
define("array/flatMap", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const { push } = Array.prototype;
    /**
     *
     * Calls a function on every item in an array and concatenates the resulting arrays into a single flat array.
     *
     * @typeparam TValue The type of items in the input array
     * @typeparam TNext the type of items in the output array
     * @param array The input array to be mapped
     * @param fn The functions used to generate the new items
     * @return A flat array of the resulting values
     *
     * @example
     * ```typescript
     *
     * const items = flatMap(['foo', 'bar'], word => word.split())
     * // Returns ['f', 'o', 'o', 'b', 'a', 'r']
     * ```
     *
     */
    function flatMap(array, fn) {
        const output = [];
        for (let i = 0; i < array.length; i++) {
            const result = fn.call(array, array[i], i);
            if (Array.isArray(result)) {
                push.apply(output, result);
            }
            else if (result !== null && result !== undefined) {
                throw new TypeError(`flatMapArray: Callback must return an array or null, received "${result}" instead`);
            }
        }
        return output;
    }
    exports.default = flatMap;
    module.exports = flatMap;
    module.exports.flatMap = flatMap;
    module.exports.default = flatMap;
});
/**
 * @module array
 */
define("array/partitionArray", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Partitions an array using a provided predicate function. All elements satisfying the predicate are part of the first returned array,
     * and all elements that don't are in the second.
     *
     * @param array The array to partition
     * @param predicate Function to test each item. Items that return true are placed in the first array,
     * otherwise they are returned in the second array
     * @param contect The context to call the predicate function in
     * @return Two arrays, the first containing all items that satisfied the predicate, the second containing the rest
     *
     * @example
     * ```typescript
     *
     * partitionArray([1, 2, 3, 4], x => x % 2)
     * // Returns [[1, 3], [2, 4]]
     * ```
     *
     */
    function partitionArray(array, predicate, context) {
        const first = [];
        const second = [];
        array.forEach((element, index) => {
            if (predicate.call(context, element, index, array)) {
                first.push(element);
            }
            else {
                second.push(element);
            }
        });
        return [first, second];
    }
    exports.default = partitionArray;
    module.exports = partitionArray;
    module.exports.partitionArray = partitionArray;
    module.exports.default = partitionArray;
});
/**
 * @module array
 */
define("array/updateItem", ["require", "exports", "accessors/get"], function (require, exports, get_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    get_3 = __importDefault(get_3);
    /**
     *
     * Updates an item in an array and returns a new array
     *
     * @param array The array to update
     * @param query A map of property paths (period delimited string) to values used to test if an object should be updated,
     * the paths are used in the get function
     * @param updateCallback A callback used to update the item
     * @return The array with the updated item
     *
     */
    function updateItem(array, query, updateCallback) {
        // Loop through all of the items
        const updatedArray = array.map(item => {
            // Assume it's a match
            let match = true;
            // If any of the query
            Object.entries(query).forEach(([path, value]) => {
                if (get_3.default(item, path) !== value)
                    match = false;
            });
            // If it met all query criteria then call the update callback
            if (match)
                return updateCallback(item);
            // Otherwise don't modify the item
            return item;
        });
        return updatedArray;
    }
    exports.default = updateItem;
});
/**
 * @module array
 * @preferred
 */
define("array/index", ["require", "exports", "array/filterBy", "array/flatMap", "array/flatten", "array/partitionArray", "array/updateItem"], function (require, exports, filterBy_1, flatMap_1, flatten_2, partitionArray_1, updateItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterBy = filterBy_1.default;
    exports.flatMap = flatMap_1.default;
    exports.flatten = flatten_2.default;
    exports.partitionArray = partitionArray_1.default;
    exports.updateItem = updateItem_1.default;
});
/**
 * @module async
 */
define("async/makeCancelable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** An error that indicates a promise has rejected because it was canceled */
    exports.canceledError = { isCanceled: true };
    /**
     *
     * Allows the provided promise to be canceled after starting. This does not stop the promise from executing but will
     * cause it to reject with the value `{ isCanceled: true }` once it finishes, regardless of outcome.
     *
     * @param promise The promise that is executing
     * @return The cancelable version of the promise
     *
     * @example
     * ```typescript
     *
     * const promise = new Promise((res, rej) => {
     *   setTimeout(() => res('I finished!'), 3000)
     * })
     *
     * // Create a cancelable version of the promise
     * const cancelablePromise = makeCancelable(promise)
     *
     * // Stop the cancelable promise from resolving
     * cancelablePromise.cancel()
     *
     * promise
     *   .then(result => console.log('Normal', result)) // This will log `'I finished!'` after 3000ms
     *   .catch(err => console.log('Normal', err)) // Will reject as per normal
     *
     * cancelablePromise
     *   .then(result => console.log('Cancelable', result)) // Never fires, the promise will not resolve after being cancelled
     *   .catch(err => console.log('Cancelable', err)) // Resolves after 3000ms with the value `{ isCanceled: true }`
     * ```
     *
     */
    function makeCancelable(promise) {
        let hasCanceled = false;
        const cancelablePromise = new Promise((resolve, reject) => {
            promise.then(val => (hasCanceled ? reject(exports.canceledError) : resolve(val)), error => (hasCanceled ? reject(exports.canceledError) : reject(error)));
        });
        cancelablePromise.cancel = () => {
            hasCanceled = true;
        };
        return cancelablePromise;
    }
    exports.default = makeCancelable;
    module.exports = makeCancelable;
    module.exports.makeCancelable = makeCancelable;
    module.exports.default = makeCancelable;
});
/** @module async */
/** */
define("async/CancelablePromise", ["require", "exports", "async/makeCancelable"], function (require, exports, makeCancelable_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.canceledError = makeCancelable_1.canceledError;
    /**
     *
     * Creates a promise that can be canceled after starting. Canceling the promise does not stop it from executing but will
     * cause it to reject with the value `{ isCanceled: true }` once it finishes, regardless of outcome.
     *
     * ```ts
     *
     * const promise = new CancelablePromise(res => setTimeout(res, 3000, 'I finished!'))
     *
     * // Stop the cancelable promise from resolving
     * cancelablePromise.cancel()
     *
     * cancelablePromise
     *   .then(result => console.log('Cancelable', result)) // Never fires, the promise will not resolve after being cancelled
     *   .catch(err => console.log('Cancelable', err)) // Resolves after 3000ms with the value `{ isCanceled: true }`
     * ```
     *
     */
    class CancelablePromise extends Promise {
        constructor(executor) {
            super((resolve, reject) => {
                return new Promise(executor).then((val) => (this.hasCanceled ? reject(makeCancelable_1.canceledError) : resolve(val)), error => (this.hasCanceled ? reject(makeCancelable_1.canceledError) : reject(error)));
            });
            this.canceled = false;
        }
        get [Symbol.toStringTag]() {
            return 'CancelablePromise';
        }
        get hasCanceled() {
            return this.canceled;
        }
        cancel() {
            this.canceled = true;
        }
        then(onfulfilled, onrejected) {
            return super.then(onfulfilled, onrejected);
        }
        catch(onrejected) {
            return super.catch(onrejected);
        }
        finally(onfinally) {
            return super.finally(onfinally);
        }
    }
    exports.CancelablePromise = CancelablePromise;
    exports.default = CancelablePromise;
});
/**
 * @module async
 */
define("async/pause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Creates a promise that resolves in the provided number of milliseconds.
     *
     * This function is basically a promise version of `setTimeout`
     *
     * @param ms The number of ms to pause for
     * @return The executing promise
     *
     * @example
     * ```typescript
     *
     * async function run() {
     *   console.log('first log')
     *   await pause(500)
     *
     *   // Will run 500 milliseconds after the first
     *   console.log('second log')
     * }
     * ```
     *
     */
    function pause(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    exports.default = pause;
});
/**
 * @module async
 * @preferred
 */
define("async/index", ["require", "exports", "async/CancelablePromise", "async/makeCancelable", "async/pause"], function (require, exports, CancelablePromise_1, makeCancelable_2, pause_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancelablePromise = CancelablePromise_1.default;
    exports.makeCancelable = makeCancelable_2.default;
    exports.pause = pause_1.default;
});
/**
 * @module function
 */
define("function/partial", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Creates a function that invokes `func` with `partials` prepended to the arguments it receives.
     *
     * @param func The function to partially apply arguments to
     * @param argsBound The arguments to be partially applied
     *
     * @example
     * ```typescript
     *
     * const addNums = (a, b, c) => a + b + c
     * const addNumsTo5 = partial(addNums, 5)
     *
     * addNumsTo5(1, 3) // => 9
     * ```
     *
     */
    function partial(func, ...argsBound) {
        return function (...args) {
            return func.call(this, ...argsBound, ...args);
        };
    }
    exports.default = partial;
    module.exports = partial;
    module.exports.partial = partial;
    module.exports.default = partial;
});
/**
 * @module function
 * @preferred
 */
define("function/index", ["require", "exports", "function/partial"], function (require, exports, partial_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partial = partial_1.default;
});
/**
 * @module tests
 */
define("tests/runTest", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Runs a test based on input(s), if an array is provided then the items are passed as arguments to the function
     * being tested, if anything else is provided then it is passed directly to the function
     *
     * @param testCase A tuple of inputs and expected output
     * @param func The function to test
     * @param testVerb The jest `expect` verb to use when testing - defaults to `toBe`
     *
     * @example
     * ```typescript
     *
     * runTest([[3, 5], 8], (a, b) => a + b)
     * ```
     *
     */
    function runTest(testCase, func, testVerb = 'toBe') {
        const [rawInputs, output] = testCase;
        // If inputs is not an array, wrap it in an array so we can use the spread operator to pass args to test
        const inputs = !Array.isArray(rawInputs) ? [rawInputs] : rawInputs;
        // If testing for errors, wrap the function in an anonymous function
        if ([
            'toThrow',
            'toThrowError',
            'toThrowErrorMatchingSnapshot',
            'toThrowErrorMatchingInlineSnapshot',
        ].includes(testVerb)) {
            const testFunc = func;
            func = (...args) => () => {
                testFunc(...args);
            };
        }
        expect(func(...inputs))[testVerb](output);
    }
    exports.default = runTest;
    module.exports = runTest;
    module.exports.runTest = runTest;
    module.exports.default = runTest;
});
/**
 * @module tests
 */
define("tests/batchTest", ["require", "exports", "tests/runTest"], function (require, exports, runTest_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    runTest_1 = __importDefault(runTest_1);
    /**
     *
     * Utility function for running batches of tests with a single call
     *
     * @param func The function to test
     * @param cases An array of test case tuples (inputs and expected outputs)
     * @param options Configuration options
     *
     * @example
     * ```typescript
     *
     * batchTest(double, [[2, 4], [5, 10]])
     * ```
     *
     */
    function batchTest(func, cases, { verb, runner } = {}) {
        // Use custom runner if provided
        const actualRunner = runner ? runner : runTest_1.default;
        // Create a test runner with the preconfigured arguments
        const testRunner = (testCase) => {
            actualRunner(testCase, func, verb);
        };
        // Run each test case with the new testRunner
        cases.forEach(testRunner);
    }
    exports.default = batchTest;
    module.exports = batchTest;
    module.exports.batchTest = batchTest;
    module.exports.default = batchTest;
});
/**
 * @module tests
 */
define("tests/buildCaseArray", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Builds an array of test cases with a common output
     *
     * @param testInputs An array of test inputs to build into the case array
     * @param output The single output that should be paired with every input
     * @return Returns the array of test cases
     *
     * @example
     * ```typescript
     *
     * const evenTests = [...buildCaseArray([2, 4, 6], true), ...buildCaseArray([1, 3, 5], false)]
     * ```
     *
     */
    function buildCaseArray(testInputs, output) {
        return testInputs.map(testCase => [testCase, output]);
    }
    exports.default = buildCaseArray;
});
/**
 * @module tests
 * @preferred
 */
define("tests/index", ["require", "exports", "tests/batchTest", "tests/buildCaseArray", "tests/runTest"], function (require, exports, batchTest_1, buildCaseArray_1, runTest_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchTest = batchTest_1.default;
    exports.buildCaseArray = buildCaseArray_1.default;
    exports.runTest = runTest_2.default;
});
define("internal/patterns/splitCamelCase", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** Regex pattern to split the camel case section into it's parts */
    const splitCamelCase = /[a-z]+|[0-9]+|(?:[A-Z][a-z]+)|([A-Z]+(?=(?:[A-Z][a-z])|[^A-Za-z]|[$\d\n]|\b))/g;
    exports.default = splitCamelCase;
});
define("internal/wordLists/articles", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Indefinite Articles
     * @internal
     */
    const articles = ['a', 'an', 'the'];
    exports.default = articles;
});
define("internal/wordLists/conjunctions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Coordinating Conjuctions
     * @internal
     */
    const conjunctions = ['and', 'but', 'or', 'nor', 'for', 'yet', 'so'];
    exports.default = conjunctions;
});
define("internal/wordLists/others", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Other miscellaneous words
     * @internal
     */
    const others = ['en', 'as', 'vs.', 'v[.]?'];
    exports.default = others;
});
define("internal/wordLists/prepositions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * All prepositions
     * @internal
     */
    exports.all = [
        'about',
        'above',
        'across',
        'after',
        'against',
        'along',
        'among',
        'around',
        'at',
        'before',
        'behind',
        'below',
        'beneath',
        'beside',
        'between',
        'beyond',
        'but',
        'by',
        'despite',
        'down',
        'during',
        'except',
        'for',
        'from',
        'in',
        'inside',
        'into',
        'like',
        'near',
        'of',
        'off',
        'on',
        'onto',
        'out',
        'outside',
        'over',
        'past',
        'per',
        'since',
        'through',
        'throughout',
        'till',
        'to',
        'toward',
        'under',
        'underneath',
        'until',
        'up',
        'upon',
        'versus',
        'via',
        'with',
        'within',
        'without',
    ];
    /**
     * Prepositions shorter than 5 characters
     * @internal
     */
    exports.short = exports.all.filter(word => word.length < 5);
    exports.default = exports.all;
});
define("internal/wordLists/titleExceptions", ["require", "exports", "internal/wordLists/articles", "internal/wordLists/conjunctions", "internal/wordLists/others", "internal/wordLists/prepositions"], function (require, exports, articles_1, conjunctions_1, others_1, prepositions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    articles_1 = __importDefault(articles_1);
    conjunctions_1 = __importDefault(conjunctions_1);
    others_1 = __importDefault(others_1);
    /** Lists of words that shouldn't be capitalized in titles */
    const except = [...articles_1.default, ...conjunctions_1.default, ...prepositions_1.short, ...others_1.default];
    exports.default = except;
});
/**
 * @module transforms
 */
define("transforms/capitalize", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Capitalize the first letter of a string
     *
     * @param text The string to be capitalized
     * @return Returns the capitalized string
     *
     * @example
     * ```typescript
     *
     * const name = capitalize('bob') // => 'Bob'
     * ```
     *
     */
    function capitalize(text) {
        const [first, ...rest] = text;
        return [first.toUpperCase(), ...rest].join('');
    }
    exports.default = capitalize;
});
/**
 * @module transforms
 */
define("transforms/camelToTitle", ["require", "exports", "internal/patterns/splitCamelCase", "internal/wordLists/titleExceptions", "transforms/capitalize"], function (require, exports, splitCamelCase_1, titleExceptions_1, capitalize_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    splitCamelCase_1 = __importDefault(splitCamelCase_1);
    titleExceptions_1 = __importDefault(titleExceptions_1);
    capitalize_1 = __importDefault(capitalize_1);
    /**
     *
     * Transforms the provided camel-case string to title case using rules from
     * [capitalizemytitle.com](https://capitalizemytitle.com/#)
     *
     * When to capitalize:
     * - Capitalize the first word in the title
     * - Capitalize the last word in the title
     *
     * When not to capitalize
     * - articles (a, an, the)
     * - coordinating conjuctions (and, but, for)
     * - short prepositions (less than 5 letters - at, by, from)
     *
     * When one of the above conditions is not met then the word is assumed to be some other important word
     * and it is capitalized
     *
     * @param input The camel-case string to be converted
     * @return Returns the transformed title case string
     *
     * @example
     * ```typescript
     *
     * camelToTitle('iLoveCamels') // => 'I Love Camels'
     * ```
     *
     */
    function camelToTitle(input) {
        // Split the string into the separate parts
        const parts = (input + ' ').match(splitCamelCase_1.default);
        // Transform each part of the string
        const newParts = parts.map((part, index) => {
            // Always capitalize the first and last words
            if (index === 0 || index === parts.length - 1) {
                return capitalize_1.default(part);
            }
            return titleExceptions_1.default.includes(part.toLowerCase()) ? part.toLowerCase() : capitalize_1.default(part);
        });
        // Return the parts separated by a space
        return newParts.join(' ');
    }
    exports.default = camelToTitle;
    module.exports = camelToTitle;
    module.exports.camelToTitle = camelToTitle;
    module.exports.default = camelToTitle;
});
/**
 * @module transforms
 */
define("transforms/getAcronym", ["require", "exports", "internal/wordLists/titleExceptions"], function (require, exports, titleExceptions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    titleExceptions_2 = __importDefault(titleExceptions_2);
    /**
     *
     * Condense a provided string into a 2 or 3 letter acronym using the following rules
     * - If there is only a single word return the first 3 letters
     * - If there are more than 3 words filter out articles, conjunctions and short prepositions
     *
     * @param title The string to convert to an acronym
     * @return Returns the acronym string
     *
     * @example
     * ```typescript
     *
     * const acronym = getAcronym('Empire Strikes Back') // => 'ESB'
     * ```
     *
     */
    function getAcronym(title) {
        // Split the words on delimiters and filter out any empties
        let words = title
            .split(/ |\.|_|,|-/g)
            .map(word => word.trim())
            .filter(word => word.length);
        // Next step depends on how many words we have
        if (words.length === 1) {
            // If there is only a single word then capitalize the first 3 letters
            return words[0].substring(0, 3).toUpperCase();
        }
        else if (words.length > 3) {
            // More than 3 words, try to filter out words in exception list
            const importantWords = words.filter(word => !titleExceptions_2.default.includes(word.toLowerCase()));
            // If we have more than 1 word left then use the filtered set otherwise use the full set
            if (importantWords.length > 1) {
                words = importantWords;
            }
        }
        else if (words.length === 0) {
            words = ['N', 'A'];
        }
        return words
            .map(word => word[0].toUpperCase())
            .join('')
            .substring(0, 3);
    }
    exports.default = getAcronym;
    module.exports = getAcronym;
    module.exports.getAcronym = getAcronym;
    module.exports.default = getAcronym;
});
/**
 * @module transforms
 */
define("transforms/normalizeURL", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Normalizes the number of slashes in the protocol section of a url
     * @private
     */
    function normalizeProtocol(urlParts) {
        // If the first part is a plain protocol we combine it with the next part
        if (urlParts[0].match(/^[^/:]+:\/*$/) && urlParts.length > 1) {
            // Strip any colon or slashes from the protocol
            const protocol = urlParts.shift().replace(/:\/*/, '');
            // Join with two slashes, next section will convert to 3 for file protocol if needed
            urlParts[0] = `${protocol}://${urlParts[0]}`;
        }
        // There must be two or three slashes in the file protocol, two slashes in anything else.
        const isFile = urlParts[0].match(/^file:\/+/);
        urlParts[0] = urlParts[0].replace(/^([^/:]+):\/*/, isFile ? '$1:///' : '$1://');
        return urlParts;
    }
    /**
     * Normalizes the number of slashes in each section of the URL
     * @private
     */
    function normalizeSectionSlashes(urlParts) {
        return urlParts
            .filter(section => section !== '')
            .map((section, i) => {
            if (typeof section !== 'string') {
                throw new TypeError(`URL must be a string. Received ${section} as argument index ${i} which is type ${typeof section}`);
            }
            // Removing the starting slashes for each component but the first.
            if (i > 0)
                section = section.replace(/^[/]+/, '');
            // Removing the ending slashes for each component but the last.
            return section.replace(/[/]+$/, i < urlParts.length - 1 ? '' : '/');
        });
    }
    /**
     *
     * Sanitises and safely joins sections of a URL, this includes removing duplicate slashes in the path and
     * ensuring correctly formatted protocols.
     *
     * @param urlParts The URL parts to be joined and normalized
     * @return Returns the joined and normalized URL parts as a string
     *
     * @example
     * ```typescript
     *
     * const url = normalizeURL('https://cahilfoley.github.io/', '/utils') // => 'https://cahilfoley.github.io/utils'
     * ```
     *
     */
    function noramlizeURL(...urlParts) {
        // Ignore empty strings at the start
        while (urlParts[0].trim() === '')
            urlParts.shift();
        // Make sure the start protocol section has the correct number of slashes
        urlParts = normalizeProtocol(urlParts);
        // Normalize the number of slashes between each section of the url
        const resultArray = normalizeSectionSlashes(urlParts);
        // Each input component is now separated by a single slash except the possible first plain protocol part.
        // Remove trailing slash before parameters or hash
        const str = resultArray.join('/').replace(/\/(\?|&|#[^!])/g, '$1');
        // replace ? in parameters with &
        const parts = str.split('?');
        return parts.shift() + (parts.length > 0 ? '?' : '') + parts.join('&');
    }
    exports.default = noramlizeURL;
    module.exports = noramlizeURL;
    module.exports.noramlizeURL = noramlizeURL;
    module.exports.default = noramlizeURL;
});
/**
 * @module transforms
 */
define("transforms/toCamel", ["require", "exports", "internal/patterns/splitCamelCase"], function (require, exports, splitCamelCase_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    splitCamelCase_2 = __importDefault(splitCamelCase_2);
    /**
     * A really basic pascal case implementation, only works for single words.
     * @ignore
     */
    function pascalCase(input) {
        const [firstLetter, ...rest] = input.split('');
        return [firstLetter.toUpperCase(), ...rest.map(letter => letter.toLowerCase())].join('');
    }
    function toCamel(input, { keepAcronyms } = {}) {
        // Split the string into the separate parts
        const parts = (input + ' ').match(splitCamelCase_2.default);
        // If `keepAcronyms` is not specified then default to true if there are any lower case characters
        const shouldKeepAcronyms = keepAcronyms !== undefined ? keepAcronyms : /[a-z]/.test(input);
        // Transform each part of the string
        const newParts = parts.map((part, index) => {
            // Always lower-case the first words
            if (index === 0) {
                return part.toLowerCase();
            }
            // If we are keeping acronyms and the part only contains capital letters, leave it as is
            if (shouldKeepAcronyms && /^[A-Z]+$/.test(part)) {
                return part;
            }
            // Otherwise, all other parts are changed to pascal case
            return pascalCase(part);
        });
        // Return the parts concatenated together
        return newParts.join('');
    }
    exports.default = toCamel;
});
/**
 * @module transforms
 */
define("transforms/toProperList", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toProperList(...items) {
        const parts = Array.isArray(items[0]) ? items[0] : items;
        // If you have 1 - 2 items in the array
        if (parts.length < 3)
            return parts.join(' and ');
        // There are 3 or more items in the array
        return (parts
            // Traverse all elements of the array adds the correct grammar according to the English language
            .map((item, index) => {
            // If it is the penultimate array item
            if (index === parts.length - 2)
                return `${item} and `;
            // If it is the last item in the array
            if (index === parts.length - 1)
                return item;
            // If it is the first or some element before the penultimate one
            return `${item}, `;
        })
            .join(''));
    }
    exports.toProperList = toProperList;
    exports.default = toProperList;
    module.exports = toProperList;
    module.exports.toProperList = toProperList;
    module.exports.default = toProperList;
});
/**
 * @module transforms
 * @preferred
 */
define("transforms/index", ["require", "exports", "transforms/camelToTitle", "transforms/capitalize", "transforms/getAcronym", "transforms/normalizeURL", "transforms/toCamel", "transforms/toProperList"], function (require, exports, camelToTitle_1, capitalize_2, getAcronym_1, normalizeURL_1, toCamel_1, toProperList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelToTitle = camelToTitle_1.default;
    exports.capitalize = capitalize_2.default;
    exports.getAcronym = getAcronym_1.default;
    exports.normalizeURL = normalizeURL_1.default;
    exports.toCamel = toCamel_1.default;
    exports.toProperList = toProperList_1.default;
});
/**
 * @module validation
 */
define("validation/isNonEmptyString", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * Checks if a value provided is of type string and has a non-zero length. If the value is not a string
     * or it is an empty string then the function returns false
     *
     * @param text The text to validate
     * @return True if the value is an empty string, false otherwise
     *
     * @example
     * ```typescript
     *
     * const valid = isNonEmptyString('hello') // => true
     * ```
     *
     */
    function isNonEmptyString(text) {
        if (typeof text === 'string') {
            return text.trim().length > 0;
        }
        return false;
    }
    exports.default = isNonEmptyString;
});
define("internal/patterns/emailAddress", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const emailPattern = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    exports.default = emailPattern;
});
/**
 * @module validation
 */
define("validation/isValidEmail", ["require", "exports", "internal/patterns/emailAddress"], function (require, exports, emailAddress_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    emailAddress_1 = __importDefault(emailAddress_1);
    /**
     *
     * Tests if the input string is in the form of a valid email address
     *
     * @param text The text to
     * @return Returns true if the input is a valid email address otherwise returns false
     *
     * @example
     * ```typescript
     *
     * isValidEmail(`no spaces@sham.co`) // => false
     * ```
     *
     */
    function isValidEmail(text) {
        return emailAddress_1.default.test(text);
    }
    exports.default = isValidEmail;
    module.exports = isValidEmail;
    module.exports.isValidEmail = isValidEmail;
    module.exports.default = isValidEmail;
});
define("internal/patterns/validURL", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** Regular expression to match URL patterns, developed using this handy tool https://regex101.com/r/lQ1nI3/1 */
    const urlRegex = new RegExp([
        '^(https?:\\/\\/)',
        '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}',
        '|([a-z\\d]([a-z\\d-]*[a-z\\d])*)',
        '|(\\d{1,3}\\.){3}\\d{1,3})',
        '(\\:\\d+)?',
        '(\\/[-a-z\\d%_.~+]*)*',
        '(\\?(?:[;&a-z\\d%_.~+=\\-/]+[^#])*)?',
        '(\\#[-a-z\\d_]*)?$',
    ].join(''), 'i');
    exports.default = urlRegex;
});
/**
 * @module validation
 */
define("validation/isValidURL", ["require", "exports", "internal/patterns/validURL"], function (require, exports, validURL_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    validURL_1 = __importDefault(validURL_1);
    /**
     *
     * Checks if a value provided is of type string and is a valid URL. If the value is not a string
     * or it is an empty string then the function returns false
     *
     * @param text The text to validate
     * @return Returns true if the input is a valid URL otherwise returns false
     *
     * @example
     * ```typescript
     *
     * const valid = isValidURL('http://www.google.com') // returns true
     * ```
     *
     */
    function isValidURL(text) {
        return typeof text === 'string' && validURL_1.default.test(text);
    }
    exports.default = isValidURL;
    module.exports = isValidURL;
    module.exports.isValidURL = isValidURL;
    module.exports.default = isValidURL;
});
/**
 * @module validation
 * @preferred
 */
define("validation/index", ["require", "exports", "validation/isNonEmptyString", "validation/isValidEmail", "validation/isValidURL"], function (require, exports, isNonEmptyString_1, isValidEmail_1, isValidURL_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNonEmptyString = isNonEmptyString_1.default;
    exports.isValidEmail = isValidEmail_1.default;
    exports.isValidURL = isValidURL_1.default;
});
define("index", ["require", "exports", "accessors/index", "array/index", "async/index", "function/index", "tests/index", "transforms/index", "validation/index"], function (require, exports, accessors_1, array_1, async_1, function_1, tests_1, transforms_1, validation_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(accessors_1);
    __export(array_1);
    __export(async_1);
    __export(function_1);
    __export(tests_1);
    __export(transforms_1);
    __export(validation_1);
});
