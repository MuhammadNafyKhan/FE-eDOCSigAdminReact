/** @module async */
/** */
import { canceledError } from './makeCancelable';
export { canceledError };
/**
 *
 * Creates a promise that can be canceled after starting. Canceling the promise does not stop it from executing but will
 * cause it to reject with the value `{ isCanceled: true }` once it finishes, regardless of outcome.
 *
 * ```ts
 *
 * const promise = new CancelablePromise(res => setTimeout(res, 3000, 'I finished!'))
 *
 * // Stop the cancelable promise from resolving
 * cancelablePromise.cancel()
 *
 * cancelablePromise
 *   .then(result => console.log('Cancelable', result)) // Never fires, the promise will not resolve after being cancelled
 *   .catch(err => console.log('Cancelable', err)) // Resolves after 3000ms with the value `{ isCanceled: true }`
 * ```
 *
 */
export declare class CancelablePromise<T extends any> extends Promise<T> {
    private canceled;
    protected promise: Promise<T>;
    get [Symbol.toStringTag](): string;
    get hasCanceled(): boolean;
    constructor(executor: (resolve: (value: T) => void, reject: (err?: any) => void) => void);
    cancel(): void;
    then<TResult1, TResult2>(onfulfilled: (value: T) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
    catch<TResult>(onrejected: (reason: any) => TResult | PromiseLike<TResult>): Promise<T | TResult>;
    finally(onfinally: () => void): Promise<T>;
}
export default CancelablePromise;
