/** @module async */
/** */
import { canceledError } from './makeCancelable';
export { canceledError };
/**
 *
 * Creates a promise that can be canceled after starting. Canceling the promise does not stop it from executing but will
 * cause it to reject with the value `{ isCanceled: true }` once it finishes, regardless of outcome.
 *
 * ```ts
 *
 * const promise = new CancelablePromise(res => setTimeout(res, 3000, 'I finished!'))
 *
 * // Stop the cancelable promise from resolving
 * cancelablePromise.cancel()
 *
 * cancelablePromise
 *   .then(result => console.log('Cancelable', result)) // Never fires, the promise will not resolve after being cancelled
 *   .catch(err => console.log('Cancelable', err)) // Resolves after 3000ms with the value `{ isCanceled: true }`
 * ```
 *
 */
export class CancelablePromise extends Promise {
    constructor(executor) {
        super((resolve, reject) => {
            return new Promise(executor).then((val) => (this.hasCanceled ? reject(canceledError) : resolve(val)), error => (this.hasCanceled ? reject(canceledError) : reject(error)));
        });
        this.canceled = false;
    }
    get [Symbol.toStringTag]() {
        return 'CancelablePromise';
    }
    get hasCanceled() {
        return this.canceled;
    }
    cancel() {
        this.canceled = true;
    }
    then(onfulfilled, onrejected) {
        return super.then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return super.catch(onrejected);
    }
    finally(onfinally) {
        return super.finally(onfinally);
    }
}
export default CancelablePromise;
